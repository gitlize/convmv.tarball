#!/usr/bin/perl
# convmv 1.02 - converts filenames from one encoding to another
# Copyright Â© 2003 Bjoern Jacke <bjoern@j3e.de>
#
# This program comes with ABSOLUTELY NO WARRANTY; it may be copied or modified
# under the terms of the GNU General Public License version 2 as published by
# the Free Software Foundation.

# to get a man page:
# pod2man --section 1 --center=" " convmv | gzip > convmv.1.gz

=head1 NAME

convmv - converts filenames from one encoding to another

=head1 SYNOPSIS

B<convmv> [B<options>] FILE(S) ... DIRECTORY(S)

=head1 OPTIONS

=over 4

=item B<-f ENCODING>

specify the current encoding of the filename(s) from which should be converted

=item B<-t ENCODING>

specify the encoding to which the filename(s) should be converted

=item B<-i>

interactive mode (ask y/n for each action)

=item B<-r>

recursively go through directories

=item B<--nfc>

target files will be normalization form C for UTF-8 (Linux etc.)

=item B<--nfd>

target files will be normalization form D for UTF-8 (OS X etc.).

=item B<--qfrom>

be more quiet about the "from" of a rename (if it screws up your terminal
e.g.). This will in fact do nothing else than replace any non-ASCII character
(bytewise) with ? on printout, this does not affect rename operation itself.

=item B<--qto>

be more quiet about the "to" of a rename (if it screws up your terminal e.g.).
This will in fact do nothing else than replace any non-ASCII character
(bytewise) with ? on printout, this does not affect rename operation itself.

=item B<--list>

list all available encodings. To get support for more Chinese or Japanese
encodings install the HanExtra or JIS2K Encode packages.

=item B<--nosmart>

by default convmv will detect if a filename is already UTF8 encoded and will
skip this file if conversion from some charset to UTF8 should be performed.
--nosmart will also force conversion to UTF-8 for such files, which might
result in "double encoded UTF-8" (see section below).

=item B<--notest>

Needed to actually rename the files. By default convmv will just print what it
wants to do.

=item B<--replace>

if the file to which shall be renamed already exists, it will be overwritten if
the other file content is equal.

=item B<--help>

print this help

=back

=head1 DESCRIPTION

B<convmv> is meant to help convert a single filename, a directory tree and the
contained files or a whole filesystem into a different encoding. It just
converts the filenames, not the content of the files. A special feature of
convmv is that it also takes care of symlinks, also converts the symlink target
pointer in case the symlink target is being converted, too.

All this comes in very handy when one wants to switch over from old 8-bit
locales to UTF-8 locales. It is also possible to convert directories to UTF-8
which are already partly UTF-8 encoded. convmv is able to detect if certain
files are UTF-8 encoded and will skip them by default. To turn this smartness
off use the --nosmart switch.

An interoperability issue that comes with UTF-8 locales is this: Linux and
(most?) other Unix-like operating systems use the so called normalization form
C (NFC) for its UTF-8 encoding by default but do not enforce this. Darwin, the
base of the Macintosh OS enforces normalization form D (NFD), where a few
characters are encoded in a different way. On OS X it's not possible to create
NFC UTF-8 filenames because this is prevented at filesystem layer. Anywhere
else convmv is able to convert files from NFC to NFD or vice versa which makes
interoperability with such systems a lot easier.

=head2 How to undo double UTF-8 (or other) encoded filenames

Sometimes it might happen that you "double-encoded" certain filenames, for
example the file names already were UTF-8 encoded and you accidently did
another conversion from some charset to UTF-8. You can simply undo that by
converting that the other way round. The from-charset has to be UTF-8 and the
to-charset has to be the from-charset you previously accidently used. You
should check to get the correct results by doing the conversion without
--notest before, also the --qfrom option might be helpful, because the
double-encoded file names might screw up your terminal if they are being
printed - they often contain control sequences which do funny things with your
terminal window. If you are not sure about the charset which was accidently
converted from, using --qfrom is a good way to fiddle out the required encoding
without destroying the file names finally.

=head1 SEE ALSO

L<locale(1)> L<utf-8(7)> L<charsets(7)>

=head1 BUGS

eh?

=head1 AUTHOR

Bjoern Jacke
 
Send mail to bjoern [at] j3e.de for bug reports and suggestions.

=cut

require 5.008;
use Getopt::Long;
use File::Find;
use File::Basename;
use Cwd;
use Encode 'from_to','encode_utf8','decode_utf8';
use Unicode::Normalize;
use utf8;
use bytes;

Getopt::Long::Configure ("bundling");
binmode STDOUT, ":bytes";
binmode STDERR, ":bytes";

GetOptions	('nfc'=>\$opt_nfc,
		'nfd'=>\$opt_nfd,
		'f=s'=>\$opt_f,
		't=s'=>\$opt_t,
		'r'=>\$opt_r,
		'i'=>\$opt_i,
		'list'=>\$opt_list,
		'help'=>\$opt_help,
		'notest'=>\$opt_notest,
		'qfrom'=>\$opt_qfrom,
		'qto'=>\$opt_qto,
		'replace'=>\$opt_replace,
		'nosmart'=>\$opt_nosmart,
		) or exit 1;
use File::Compare;

&listvalidencodings and exit 0 if ($opt_list);
&printusage and exit 1 if (!@ARGV or $opt_help);

$opt_f=Encode::resolve_alias($opt_f) or die "wrong/unknown \"from\" encoding!\n";
$opt_t=Encode::resolve_alias($opt_t) or die "wrong/unknown \"to\" encoding!\n";
$from_is_utf8 = lc($opt_f) =~ m/^utf-?8$/;
$to_is_utf8 = lc($opt_t) =~ m/^utf-?8$/;

if ($opt_qfrom) {
	$from_print=\&to_ascii;
} else {
	$from_print=\&dummy;
}
if ($opt_qto) {
	$to_print=\&to_ascii;
} else {
	$to_print=\&dummy;
}

if ($opt_nfc) {
	$norm=\&NFC;
	die "NFC reqires UTF-8 as target charset\n" unless ($to_is_utf8);
} elsif ($opt_nfd) {
	$norm=\&NFD;
	die "NFD reqires UTF-8 as target charset\n" unless ($to_is_utf8);
} else {
	$norm=\&dummy;
}

$pwd=cwd();
@args=@ARGV;
undef @ARGV;

for (@args) {
	die "file or directory not found: $_\n" unless (-e);
}

## do {print ord($_)."_" for (split(//,$_));print "\n"; } for (@args); # debug print

if ($opt_r) {
	find({wanted=>\&scan,bydepth=>1,no_chdir=>1}, @args);
	die "To prevent damage to your files, we won't continue.\nFirst fix this or correct options!\n" if ($errors_occured);
	find({wanted=>\&process_symlink_targets,bydepth=>1,no_chdir=>1}, @args);
	find({wanted=>\&process_main,bydepth=>1,no_chdir=>1}, @args);
} else {
	for my $a (@args) { &scan($a); }
	die "To prevent damage to your files, we won't continue.\nFirst fix this or correct options!\n" if ($errors_occured);
	for my $a (@args) { &process_symlink_targets($a); }
	for my $a (@args) { &process_main($a); }
}

print STDERR "No changes to your files done. Use --notest to finally rename the files.\n" unless ($opt_notest);

#####
## subs
###

# scan for real files and check charset first:
sub scan {
	$arg=shift or $arg=$_;
	&get_dir_base_change;
	if (-l $arg) {
#		print "link: $arg in $dir\n";
		&checkenc($arg);
	} elsif (-d $arg) {
#		print "dir: $arg in $dir\n";
		$inod_fullname{(stat $arg)[1]}=$dir.$arg;
		&checkenc($arg);
	} elsif (-f $arg) {
#		print "file: $arg in $dir\n";
		$inod_fullname{(stat $arg)[1]}=$dir.$arg;
		&checkenc($arg);
	}
	chdir $pwd;
}

# move symlink targets:
sub process_symlink_targets {
	$arg=shift or $arg=$_;
	&get_dir_base_change;
	if (-l) {
		$oldlink=readlink $arg;
		if ((-f $oldlink or -d $oldlink) and $newname=&get_newname($oldlink)) {
			if ( $newname ne $oldlink ) {
				if ( $inod_fullname{(stat $oldlink)[1]}) { # = if (symlink target scanned before)
					&print_ask ("symlink \"".&$from_print($File::Find::name)."\": \"".&$from_print($oldlink)."\" >> \"".&$to_print($newname)."\"") or return;
					if ($opt_notest) {
						unlink $arg;
						symlink ($newname, $arg);
					}
				} else {
					print STDERR "link target \"",&$from_print($oldlink),"\" of \"",&$from_print($dir.$arg),"\" not in subtree, left untouched!\n";
				}
			} else { print "no need to convert link target: $oldlink to $newname\n";
			}
		}
	}
	chdir $pwd;
}

# do the changes to all the real files/dirs/links:
sub process_main {
	$arg=shift or $arg=$_;
	&get_dir_base_change;
	if (-l $arg) {
#		$type="symlink";
		$newname=&get_newname($arg) and &renameit($arg,$newname);
	} elsif (-d $arg) {
#		$type="directory";
		$newname=&get_newname($arg) and &renameit($arg,$newname);
	} elsif (-f $arg) {
#		$type="file";
		$newname=&get_newname($arg) and &renameit($arg,$newname);
	}
	chdir $pwd;
}

sub get_newname {
	my $oldfile=shift;
	my $newname;
	if (!$from_is_utf8 and $to_is_utf8 and !$opt_nosmart and &looks_like_utf8($oldfile)) {
		print STDERR "Skipping, already UTF-8: $dir$oldfile\n";
		return 0;
	} else {
		if ($from_is_utf8 and ! $to_is_utf8) {
			# from_to can't convert from NFD to non-UTF-8!
			$newname=encode_utf8(NFC(decode_utf8($oldfile)));
		} else {
			$newname=$oldfile;
		}
		from_to($newname, $opt_f, $opt_t) or die "SHOULD NOT HAPPEN HERE: conversion error, so suitable charset used?: \"$oldfile\"\nTo prevent damage to your files, we won't continue. First fix this!\n";
		$newname=&$norm(decode_utf8($newname)) if ($to_is_utf8);
		if ( $newname ne $oldfile ) {
			return $newname;
		} else {
			return 0;
		}
	}
	
}

sub get_dir_base_change() {
	$arg =~ s/\/*$//;
	$dir=dirname($arg)."/";
	$arg=basename($arg);
	chdir $dir;
}

sub renameit() {
	my $oldfile=shift;
	my $newname=shift;
	$newname=encode_utf8($newname) if ($to_is_utf8);
	&print_ask ("mv \"". &$from_print($dir.$oldfile)."\"\t\"".&$to_print($dir.$newname)."\"") or return;
	if (-e $newname) {
		if ($opt_replace and !&compare($oldfile,$newname)) {
			if ($opt_notest) {
				unlink $newname or print STDERR $!;
				rename ($oldfile, $newname) or print STDERR $!;
			}
		} else {
			print STDERR &$to_print($newname)," exists and differs or --replace option missing - skipped\n";
		}
	} else {
		if ($opt_notest) {
			rename ($oldfile, $newname) or print $!;
		}
	}
}

sub listvalidencodings() {
	print "$_\n" for (Encode->encodings(":all"));
	return 1;
}

sub checkenc() {
	my $new=shift;
	$new=encode_utf8(NFC(decode_utf8($new))) if ($from_is_utf8 and ! $to_is_utf8);
	my $oldfile=$new;
	if (! from_to($new, $opt_f, $opt_t,'')) {
		print STDERR "conversion error, no suitable charset used?: \"$dir$oldfile\"\n";
		$errors_occured=1;
		return 0;
	} elsif (! from_to($new, $opt_t, $opt_f,'')) {
		print STDERR "back-conversion error, no suitable charset used?: \"$dir$oldfile\"\n";
		$errors_occured=1;
		return 0;
	} elsif ($new ne $oldfile) {
		print STDERR "$opt_t doesn't cover all needed characters for: \"$dir$oldfile\"\nAnother reason might be the file was not validly encoded in $opt_f.\n";
		$errors_occured=1;
		return 0;
	}
	return 1;
}

sub printusage {
	print <<END;
convmv 1.02 - converts filenames from one encoding to another
Copyright (C) 2003 Bjoern Jacke <bjoern\@j3e.de>

This program comes with ABSOLUTELY NO WARRANTY; it may be copied or modified
under the terms of the GNU General Public License version 2 as published by
the Free Software Foundation.

 USAGE: convmv [options] FILE(S)
-f enc    encoding *from* which should to converted
-t enc    encoding *to* which should to converted
-r        recursively go through directories
-i        interactive mode (ask for each action)
--nfc     target files will be normalization form C for UTF-8 (Linux etc.)
--nfd     target files will be normalization form D for UTF-8 (OS X etc.)
--qfrom   be quiet about the "from" of a rename (if it screws up your terminal e.g.)
--qto     be quiet about the "to" of a rename (if it screws up your terminal e.g.)
--list    list all available encoding
--nosmart ignore if files already seem to be UTF-8 and convert is posible
--notest  just print out to stdout what will be done
--replace will replace files if they are equal
--help    print this help
END
}

sub looks_like_utf8() {
	my $string = shift;
	if (not $string =~ m/^[[:ascii:]]*$/ and decode_utf8($string)) {
		return 1;
	} else { return 0; }
}

sub to_ascii() {
	my $a=shift;
	$a =~ s/[^[:ascii:]]/?/g;
	return $a;
}

sub dummy() {
	return shift;
}

sub print_ask() {
	my $a="";
	print shift;
	while ($opt_i and not $a =~ m/^[yn]$/i) {
		print " (y/n) ";
		$a=<>;
	}
	print "\n";
	if ($a =~ m/^n$/i) {
		return 0;
	} else {
		return 1;
	}
}
